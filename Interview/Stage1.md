[TOC]

# Stage1
#### 面向对象的特征有哪些方面?
**面向对象的特征主要有以下几个方面：**

1. 抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象,二是数据抽象。
2. 继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。
3. 封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象,这些对象通过一个受保护的接口访问其他对象。
4. 多态性：多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。
#### 作用域public,private,protected,以及不写时的区别？
区别如下：  
|作用域|当前类|同包|子孙类|其他|
| -   | -  | - | - | - |  
| public | √  | √  | √  | √  |  
| protected | √  | √  | √  | × |  
| public | √  | √  | ×  | ×  |  
| public | √  | ×  | ×  | ×  |  

不写时默认为default,但注意此单词不能写出,写出会报错.
#### String 是最基本的数据类型吗?
不是.String是引用类型,底层维护的是char类型的数组
#### float 型float f=3.4是否正确?
不正确.浮点型的字面值类型是double,所以应该强制类型转换3.4为float类型float f=(float)3.4
#### short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
short s1 = 1; s1 = s1 + 1;s1+1运算结果是int 型，需要强制转换类型；short s1 = 1; s1 += 1;可以正确编译,自动类型提升。
#### Java 有没有goto?
goto 是java 中的保留字，现在没有在java 中使用。
#### int 和Integer 有什么区别?
- Java 提供两种不同的类型：引用类型和原始类型（或基本类型）；  
- int 是java 的原始数据类型，Integer 是java 为int 提供的封装类。  
- Java 为每个原始类型提供了封装类：  
- 原始类型: boolean,char,byte,short,int,long,float,double  
- 封装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double引用类型和基本类型的行为完全不同，并且它们具有不同的语义。引用类型和基本类型具有不同的特征和用法，它们包括：大小和速度问题，这种类型以哪种类型的数据结构存储，当引用类型和基本类型用作某个类的实例数据时所指定的默认值。对象引用实例变量的默认值为null，而基本类型实例变量的默认值与它们的类型有关。
#### &和&&的区别？
&是位运算符，表示按位与运算，&&是逻辑运算符，表示逻辑与（and）,有短路的作用。
#### 简述逻辑操作(&,|,^)与条件操作(&&,||)的区别？
**区别主要有两点：**
1. 条件操作只能操作布尔型的,而逻辑操作不仅可以操作布尔型,而且可以操作数值型
2. 逻辑操作不会产生短路。
#### stack 是什么？
栈是一种线形集合，其添加和删除元素的操作按照后进先出的方式进行处理；
#### swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?
switch（express）中，express 是一个整数表达式,支持的参数参数有:byte、int、short、char、String与enum
#### 编程题: 用最有效率的方法算出2 乘以8 等于几?
2 << 3。 左移符号,此处可以理解成2乘以2的3次方,0b10左移3位得到0b10000,即为16
#### 数组有没有length()这个方法? String 有没有length()这个方法？
数组没有length()这个方法，有length 的属性。String 有length()这个方法。
#### 构造器Constructor 是否可被override?
构造器Constructor 不能被继承，因此不能重写Overriding，但可以被重载Overloading。
#### 是否可以继承String 类?
String 类是final 类，故不可以继承。
#### 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
是值传递。Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。
#### String 和StringBuffer 的区别?
JAVA 平台提供了两个类：String 和StringBuffer，它们可以储存和操作字符串，即包含多个字符的字符数据。这个String 类提供了数值不可改变的字符串。而这个StringBuffer 类提供的字符串进行修改。当你知道字符数据要改变的时候你就可以使用StringBuffer。
#### String, StringBuffer StringBuilder 的区别。
String 的长度是不可变的；StringBuffer 的长度是可变的，如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer 的toString()方法；线程安全；StringBuilder 是从JDK 5 开始，为StringBuffer 该类补充了一个单个线程使用的等价类；通常应该优先使用StringBuilder 类，因为它支持所有相同的操作，但由于它不执行同步，所以速度更快。
#### Overload 和Override 的区别。Overloaded 的方法是否可以改变返回值的类型?
方法的重写Overriding 和重载Overloading 是Java 多态性的不同表现。重写Overriding 是父类与子类之间多态性的一种表现，重载Overloading 是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded 的方法是可以改变返回值的类型。
#### 描述一下JVM 加载class 文件的原理机制?
JVM 中类的装载是由ClassLoader 和它的子类来实现的,Java ClassLoader是一个重要的Java 运行时系统组件。它负责在运行时查找和装入类文件的类。
#### abstract class 和interface 有什么区别?
抽象类是一个特殊的类,特殊在,抽象类中可以包含没有方法体的方法(抽象方法)  
接口可以理解成一个特殊的抽象类,特殊在,接口里的都是抽象方法,没有普通方法  
接口会为方法自动拼接public abstract,还会为变量自动拼接public final static  
抽象类可以有构造方法–用来给子类创建对象,接口中没有构造方法  
抽象类和接口都不能实例化(创建对象)  
接口可继承接口，并可多继承接口，但类只能单继承  
抽象方法只能声明，不能实现，接口是设计的结果 ，抽象类是重构的结果  
#### java 中会存在内存泄漏吗，请简单描述。
会；存在无用但可达的对象，这些对象不能被GC 回收，导致耗费内存资源。
#### 静态变量和实例变量的区别？
静态变量也称为类变量，归全类共有，它不依赖于某个对象，可通过类名直接访问；而实例变量必须依存于某一实例，只能通过对象才能访问到它。
#### 是否可以从一个static 方法内部发出对非static 方法的调用？
不可以,如果其中包含对象的method()，不能保证对象初始化。静态只能调用静态
#### GC 是什么? 为什么要有GC?
GC 是垃圾收集的意思（Gabage Collection）,内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java 提供的GC 功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java 语言没有提供释放已分配内存的显示操作方法。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：System.gc() 或Runtime.getRuntime().gc() 。
#### 垃圾回收的优点和原理。并考虑2 种回收机制。
Java 语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。
#### 垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
对于GC 来说，当程序员创建对象时，GC 就开始监控这个对象的地址、大小以及使用情况。通常，GC 采用有向图的方式记录和管理堆(heap)中的所有对象。通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC 确定一些对象为"不可达"时，GC 就有责任回收这些内存空间。可以。程序员可以手动执行System.gc()，通知GC 运行，但是Java 语言规范并不保证GC 一定会执行。
#### String s=new String(“xyz”);创建了几个String Object?
两个对象，一个是"xyx",一个是指向"xyx"的引用对象s。
#### 接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类(concrete  class)?
接口可以继承接口。抽象类可以实现(implements)接口，抽象类可继承实体类，但前提是实体类必须有明确的构造函数。
#### Java 的接口和C++的虚类的相同和不同处。
由于Java 不支持多继承，而有可能某个类或对象要使用分别在几个类或对象里面的方法或属性，现有的单继承机制就不能满足要求。与继承相比，接口有更高的灵活性，因为接口中没有任何实现代码。当一个类实现了接口以后，该类要实现接口里面所有的方法和属性，并且接口里面的属性在默认状态下面都是public static,所有方法默认情况下是public.一个类可以实现多个接口。
#### 一个“.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？
可以；必须只有一个类名与文件名相同。
#### 内部类可以引用他包含类的成员吗？有没有什么限制？
一个内部类对象可以访问创建它的外部类对象的内容。
#### 在java 中一个类被声明为final 类型，表示了什么意思？
表示该类不能被继承，是顶级类。
#### 下面哪些类可以被继承?
1. java.lang.Thread (T)
2. java.lang.Number (T)
3. java.lang.Double (F)
4. java.lang.Math (F)
5. java.lang.Void (F)
6. java.lang.Class (F)
7. java.lang.ClassLoader (T)  

**答：1、2、7 可以被继承。**
#### 数据类型之间的转换:
1. 如何将数值型字符转换为数字？  
   调用数值类型相应包装类中的方法parse***(String)或valueOf(String)即可返回相应基本类型或包装类型数值；
2. 如何将数字转换为字符？  
   将数字与空字符串相加即可获得其所对应的字符串;另外对于基本类型数字还可调用String 类中的valueOf(…)方法返回相应字符串,而对于包装类型数字则可调用其toString()方法获得相应字符串；
3. 如何取小数点前两位并四舍五入?  
   可用该数字构造一java.math.BigDecimal 对象,再利用其round()方法进行四舍五入到保留小数点后两位,再将其转换为字符串截取最后两位。
#### 字符串操作：如何实现字符串的反转及替换？
可用字符串构造一StringBuffer 对象,然后调用StringBuffer 中的reverse方法即可实现字符串的反转,调用replace 方法即可实现字符串的替换。
#### 编码转换：怎样将GB2312 编码的字符串转换为ISO-8859-1 编码的字符串？
示例代码如下:
String s1 = "你好";
String s2 = new String(s1.getBytes("GB2312"), "ISO-8859-1");
#### 日期和时间：
1. 如何取得年月日、小时分秒？  
   创建java.util.Calendar 实例(Calendar.getInstance()),调用其get()方法传入不同的参数即可获得参数所对应的值,如：calendar.get(Calendar.YEAR);//获得年
2. 如何取得从1970 年到现在的毫秒数？  
   以下方法均可获得该毫秒数:Calendar.getInstance().getTimeInMillis();System.currentTimeMillis();
3. 如何取得某个日期是当月的最后一天？  
   示例代码如下:  
   ```java
   Calendar time = Calendar.getInstance();
   time.set(Calendar.DAY_OF_MONTH,
   time.getActualMaximum(Calendar.DAY_OF_MONTH));
   ```
4. 如何格式化日期？  
   利用java.text.DataFormat 类中的format()方法可将日期格式化。
#### Java 中的异常处理机制的简单原理和应用？
当JAVA 程序违反了JAVA 的语义规则时，JAVA 虚拟机就会将发生的错误表示为一个异常。违反语义规则包括2 种情况。一种是JAVA 类库内置的语义检查。例如数组下标越界,会引发IndexOutOfBoundsException;访问null 的对象时会引发NullPointerException。另一种情况就是JAVA 允许程序员扩展这种语义检查，程序员可以创建自己的异常，并自由选择在何时用throw 关键字引发异常。所有的异常都是java.lang.Thowable 的子类。
#### error 和exception 有什么区别?
error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下的一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。
#### try {}里有一个return 语句，那么紧跟在这个try 后的finally {}里的code会不会被执行，什么时候被执行，在return 前还是后?
会执行，在return 前执行。
#### JAVA 语言如何进行异常处理，关键字：throws,throw,try,catch,finally分别代表什么意义？在try 块中可以抛出异常吗？
Java 通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java 中，每个异常都是一个对象，它是Throwable 类或其它子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并进行处理。Java 的异常处理是通过5 个关键词来实现的：try、catch、throw、throws 和finally。一般情况下是用try 来执行一段程序，如果出现异常，系统会抛出（throws）一个异常，这时候你可以通过它的类型来捕捉（catch）它，或最后（finally）由缺省处理器来处理；try 用来指定一块预防所有“异常”的程序；catch 子句紧跟在try 块后面，用来指定你想要捕捉的“异常”的类型；throw 语句用来明确地抛出一个“异常”；throws 用来标明一个成员函数可能抛出的各种“异常”；Finally 为确保一段代码不管发生什么“异常”都被执行一段代码；可以在一个成员函数调用的外面写一个try 语句，在这个成员函数内部写另一个try 语句保护其他代码。每当遇到一个try 语句，“异常”的框架就放到堆栈上面，直到所有的try 语句都完成。如果下一级的try 语句没有对某种“异常”进行处理，堆栈就会展开，直到遇到有处理这种“异常”的try 语句。
#### 运行时异常与一般异常有何异同？
异常表示程序运行过程中可能出现的非正常状态，运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误。java 编译器要求方法必须声明抛出可能发生的非运行时异常，但是并不要求必须声明抛出未被捕获的运行时异常。
#### 给我一个你最常见到的runtime exception？

| ArithmeticException        | ArrayStoreException      | ArrayStoreException              | BufferOverflowException          | BufferUnderflowException            |
| -------------------------- | :----------------------- | -------------------------------- | -------------------------------- | ----------------------------------- |
| **CannotRedoException**    | **CannotUndoException**  | **ClassCastException**           | **CMMException**                 | **ConcurrentModificationException** |
| **DOMException**           | **EmptyStackException**  | **IllegalArgumentException**     | **IllegalMonitorStateException** | **IllegalPathStateException**       |
| **IllegalStateException**  | **ImagingOpException**   | **IndexOutOfBoundsException**    | **MissingResourceException**     | **NegativeArraySizeException**      |
| **NoSuchElementException** | **NullPointerException** | **ProfileDataException**         | **ProviderException**            | **RasterFormatException**           |
| **SecurityException**      | **SystemException**      | **UndeclaredThrowableException** | **UnmodifiableSetException**     | **UnsupportedOperationException**   |

#### final, finally, finalize 的区别?
- final：修饰符（关键字）；如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承，因此一个类不能既被声明为abstract的，又被声明为final 的；将变量或方法声明为final，可以保证它们在使用中不被改变；被声明为final 的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改；被声明为final 的方法也同样只能使用，不能重载。  
- finally：再异常处理时提供finally 块来执行任何清除操作；如果抛出一个异常，那么相匹配的catch 子句就会执行，然后控制就会进入finally 块（如果有的话）。  
- finalize：方法名；Java 技术允许使用finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在Object 类中定义的，因此所有的类都继承了它。子类覆盖finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。
#### 介绍JAVA 中的Collection FrameWork(及如何写自己的数据结构)
**Collection FrameWork 如下：**  
Collection
├List
│├LinkedList
│├ArrayList
│└Vector
│ └Stack
└Set
Map
├Hashtable
├HashMap
└WeakHashMap  
Collection 是最基本的集合接口，一个Collection 代表一组Object，即Collection 的元素（Elements）； Map  提供key 到value 的映射。

#### List,Set,Map 是否继承自Collection 接口？
List,Set 是；Map 不是。
#### 你所知道的集合类都有哪些？主要方法？
最常用的集合类是List 和Map。List 的具体实现包括ArrayList 和Vector，它们是可变大小的列表，比较适合构建、存储和操作任何类型对象的元素列表。List 适用于按数值索引访问元素的情形。Map 提供了一个更通用的元素存储方法。Map 集合类用于存储元素对（称作“键”和“值”），其中每个键映射到一个值。
#### 说出ArrayList,Vector, LinkedList 的存储性能和特性？
ArrayList 和Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 由于使用了synchronized 方法（线程安全），通常性能上较ArrayList 差，而LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。
#### Collection 和Collections 的区别？
Collection 是java.util 下的接口，它是各种集合的父接口，继承于它的接口主要有Set 和List；Collections 是个java.util 下的类，是针对集合的帮助类，提供一系列静态方法实现对各种集合的搜索、排序、线程安全化等操作。
#### HashMap 和Hashtable 的区别?
二者都实现了Map 接口，是将惟一键映射到特定的值上；主要区别在于：  
1. HashMap 没有排序，允许一个null 键和多个null 值,而Hashtable 不允许；
2. HashMap 把Hashtable 的contains 方法去掉了，改成containsvalue 和containsKey,因为contains 方法容易让人引起误解；
3. Hashtable 继承自Dictionary 类，HashMap 是Java1.2 引进的Map 接口的实现；
4. Hashtable 的方法是Synchronize 的，而HashMap 不是，在多个线程访问Hashtable 时，不需要自己为它的方法实现同步，而HashMap 就必须为之提供外同步。Hashtable 和HashMap 采用的hash/rehash 算法大致一样，所以性能不会有很大的差异。
#### List、Map、Set 三个接口，存取元素时，各有什么特点？
List 以特定次序来持有元素，可有重复元素。Set 无法拥有重复元素,内部排序。Map 保存key-value  值，value 可多值。
#### Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()? 它们有何区别?
Set 里的元素是不能重复的，用equals ()方法来区分重复与否。覆盖equals()方法用来判断对象的内容是否相同，而”==”判断地址是否相等,用来决定引用值是否指向同一对象。
#### sleep() 和wait() 有什么区别?
sleep 是线程类（Thread）的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。调用sleep 不会释放对象锁。wait 是Object 类的方法，对此对象调用wait 方法导致本线程放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify 方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。
#### 当一个线程进入一个对象的一个synchronized 方法后，其它线程是否可进入此对象的其它方法?
其它线程只能访问该对象的其它非同步方法，同步方法则不能进入。
#### 请说出你所知道的线程同步的方法。
- wait():使一个线程处于等待状态，并且释放所持有的对象的lock；sleep():使一个正在运行的线程处于睡眠状态，是一个静态方法，调用此方法要捕捉InterruptedException 异常；notify():唤醒一个处于等待状态的线程，注意的是在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM 确定唤醒哪个线程，而且不是按优先级；  
- notityAll():唤醒所有处入等待状态的线程，注意并不是给所有唤醒线程一个对象的锁，而是让它们竞争。
#### 多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么?
多线程有两种实现方法，分别是继承Thread 类与实现Runnable 接口,同步的实现方面有两种，分别是synchronized,wait 与notify。
#### 同步和异步有何异同，在什么情况下分别使用他们？举例说明。
如果数据将在线程间共享。例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就是共享数据，必须进行同步存取。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。
#### 启动一个线程是用run()还是start()?
启动一个线程是调用start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由JVM 调度并执行。这并不意味着线程就会立即运行。run()方法可以产生必须退出的标志来停止一个线程。
#### 线程的基本概念、线程的基本状态以及状态之间的关系？
线程指在程序执行过程中，能够执行程序代码的一个执行单位，每个程序至少都有一个线程，也就是程序本身；Java 中的线程有四种状态分别是：运行、就绪、挂起、结束。
#### 简述synchronized 和java.util.concurrent.locks.Lock 的异同？
主要相同点：Lock 能完成synchronized 所实现的所有功能；主要不同点：Lock 有比synchronized 更精确的线程语义和更好的性能。synchronized 会自动释放锁，而Lock 一定要求程序员手工释放，并且必须在finally 从句中释放。
#### 什么是java 序列化，如何实现java 序列化？
序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决在对对象流进行读写操作时所引发的问题；序列化的实现：将需要被序列化的类实现Serializable 接口，该接口没有需实现的方法，implements Serializable 只是为了标注该对象是可被序列化的，然后使用一个输出流(如FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream 对象的writeObject(Object obj)方法就可以将参数为obj 的对象写出(即保存其状态)，要恢复的话则用输入流。
#### java 中有几种类型的流？JDK 为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？
字节流，字符流。字节流继承于InputStream、OutputStream，字符流继承于Reader、Writer。在java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。
#### Java 中常用的设计模式？说明工厂模式？
Java 中的23 种设计模式：Factory（ 工厂模式），Builder（ 建造模式）， Factory  Method（工厂方法模式），Prototype（原始模型模式），Singleton（单例模式），Facade（门面模式），Adapter（适配器模式）， Bridge（桥梁模式）， Composite（合成模式），Decorator（装饰模式）， Flyweight（享元模式），  Proxy（代理模式），Command（命令模式）， Interpreter（解释器模式）， Visitor（访问者模式），Iterator（迭代子模式）， Mediator（调停者模式）， Memento（备忘录模式），Observer（观察者模式），State（状态模式），Strategy（策略模式），Template Method（模板方法模式）， Chain Of Responsibleity（责任链模式）。  
工厂模式：工厂模式是一种经常被使用到的模式，根据工厂模式实现的类可以根据提供的数据生成一组类中某一个类的实例，通常这一组类有一个公共的抽象父类并且实现了相同的方法，但是这些方法针对不同的数据进行了不同的操作。首先需要定义一个基类，该类的子类通过不同的方法实现了基类中的方法。然后需要定义一个工厂类，工厂类可以根据条件生成不同的子类实例。当得到子类的实例后，开发人员可以调用基类中的方法而不必考虑到底返回的是哪一个子类的实例。
#### 开发中都用到了那些设计模式?用在什么场合?
每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC 的设计模式，用来开发JSP/Servlet或者J2EE 的相关应用；及简单工厂模式等。
#### 你对软件开发中迭代的含义的理解；
软件开发中，各个开发阶段不是顺序执行的，应该是并行执行,也就是迭代的意思。这样对于开发中的需求变化，及人员变动都能得到更好的适应。
#### java跨平台是如何实现的?
Java是利用JVM ( Java虚拟机)实现跨平台的。  
Java源代码( *.java )经过Java编译器编译成Java字节码( *.class )，,执行Java字节 码, Java字节码经过JVM解释为具体平台的具体指令,并执行。不同平台有不同的JVM , 主流平台都提供了JVM ,所以Java字节码可以在主流平台上能够解释执行。在这个意义上 Java是跨平台的,也就是说: Java的字节码是跨平台的。
#### 这你认为Java与其他(你所了解的)语言相比,有什么优点和缺点?
首先,Java与C/C++相比。Java语言是一种完全的面向对象语言,虽然它的底层(运行时库)是用C语言开发的,可是并不依赖于C。因为Java的运行是在运行时库的支持下进行的,所以运行效率比起可以更接近底层的C/C++来说效率会有所影响,不过Java的类库采用很好的设计理念,非常好用,也非常实用,已经成为业界的一种标准开发语言。它的跨平台的特性受到开发者的青睐,只需要开发一次就能在所有安装了Java运行时库的环境上运行。其次,Java与C#相比。C#是微软开发的一种编程语言,语法类似Java几乎就是Java的翻版。运行原理和Java也类似,也是通过运行时库的支持运行。不过支持的平台还很有限。Java几乎被所有平台支持,而C#目前只被Windows和linux支持,Windows下的支持当然是由微软自己开发的,而Linux下的支持则有mono支持。实际上,mono也是把C#应用转化为Java应用而已所以本质上,C#仍然只是被微软自己的操作系统支持。应用平台受到限制,是它最大的缺点。
#### 请回答以下几个名词的意思: JVM、JDK、JRE
- JVM:Java虚拟机,Java Virtual Machine的缩写。是一个虚构出来的计算机,通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构,如处理器、堆栈、寄存器等,还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码(字节码),就可以在多种平台上不加修改地运行。
- JDK:Java开发工具包,Java Development Kit的缩写。JDK是整个Java的核心,包括了Java运行环境、Java工具和Java基础类库。
- JRE:Java运行环境,Java Runtime Environment的缩写。运行JAVA程序所必须的环境的集合,包含JVM标准实现及Java核心类库。
#### 类、方法、变量、包、常量的命名要符合哪些规范?
1. 类命名规范:首字母大写，如果由多个单词合成一个类名,要求每个单词的首字母也要大写,如:HelloWorld.
2. 方法命名规范:首字母小写，中间的每个单词的首字母都要大写，如:getName。
3. 变量的命名规范:变量的命名规范和方法一-样,首字母小写,中间的每个单词的首字母都要大写,如:name。
4. 包的命名规范:Java包的名字都是由小写单词组成。但是由于Java面向对象编程的特性,每一名Java程序员都可以编写属于自己的Java包,为了保障每个Java包命名的 唯一性，在最新的Java编程规范中,要求程序员在自己定义的包的名称之前加.上唯一的前缀。由于互联网上的域名称是不会重复的,所以程序员-般采用自己在互联网上的域名称作为自己程序包的唯一前缀。例如:”com.sun.swt"一般公司命名会以“com.公司名项目名.模块名“开头，所以会长一点,如com.land.oa.emp.struts.action.
5. 常量的命名规范:基本数据类型的常量名为全大写,如果是由多个单词构成，可以用下划线隔开,如:WEEK_OF_MONTH。
#### 如何增加代码的清晰度和可观性?
**增加代码的清晰度和可观性常用的方式如下:**
1. 给代码添加注释。
2. 类名/包名等命名规范化。
3. 缩进排版规范。
4. 添加异常的处理。
5. 使用测试类和测试方法。
#### 阐述一下static关键字的作用?
static表示"静态”的意思,用来修饰成员变量和成员方法,也可以形成静态代码块。 只要这个类被加载,Java 虚拟机就能根据类名在运行时数据区的方法区内找到它们。因此，static成员可以在它的任何对象创建之前访问,无需引用任何对象。  
1. 修饰成员变量。用static修饰的成员变量不属于对象的数据结构; static变量是属 于类的变量,通常可以通过类名来引用static 成员; static成员变量和类的信息-起存储在方法区，而不是在堆中,-个类的static成员变量只有“一份”,无论该类创建了多少对象
2. 修饰成员方法。static 修饰的方法则不需要针对某些对象进行操作,其运行结果仅仅与输入的参数有关,调用时直接用类名引用。由于static在调用时没有具体的对象,因此 在static方法中不能对非static 成员(对象成员)进行访问。static 方法的作用在于提供一些“工具方法”和“工厂方法”等
3. static块:属于类的代码块,在类加载期间执行的代码块,只执行一 -次,可以用来在软件中加载静态资源。
#### 线程池是什么?
当一个程序中若创建大量线程,并在任务结束后销毁,会给系统带来过度消耗资源,以及过度切换线程的危险,从而可能导致系统崩溃。为此我们应使用线程池来解决这个问题。首先创建一些线程,它们的集合称为线程池,当服务器接受到一个客户请求后,就从线 程池中取出一个空闲的线程为之服务, 服务结束后不关闭该线程,而是将该线程还回到线程池中。在线程池的编程模式下,任务是提交给整个线程池,而不是直接交给某个线程,线程 池在拿到任务后, 它就在内部找有无空闲的线程,再把任务交给内部某个空闲的线程, 一个线程同时只能执行一个任务,但可以同时向一个线程池提交多个任务。
#### 简单说明什么是递归?什么情况会使用?并使用Java实现一个简单的递归程序?
递归做为一种算法在程序设计语言中广泛应用,是指函数/过程/子程序在运行过程中直接或间接调用自身而产生的重入现象。递归算法-般用于解决三类问题:
1. 数据的定义是按递归定义的。(Fibonacci (斐波那契)函数)
2. 问题解法按递归算法实现。(回溯)
3. 数据的结构形式是按递归定义的。(树的遍历,图的搜索)
#### 描述一下JAVA 四中引用类型
1. 强引用
   - 在 Java 中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。
2. 软引用
   - 软引用需要用 SoftReference 类来实现，对于只有软引用的对象来说，当系统内存足够时它不会被回收，当系统内存空间不足时它会被回收。软引用通常用在对内存敏感的程序中。
3. 弱引用
   - 弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。
4. 虚引用
   - 虚引用需要 PhantomReference 类来实现，它不能单独使用，必须和引用队列联合使用。 虚引用的主要作用是跟踪对象被垃圾回收的状态。